"""Rule engine for evaluating findings against YAML-based detection rules."""
from __future__ import annotations

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from soc_audit.core.interfaces import Finding


def _load_yaml(raw_text: str) -> dict[str, Any]:
    """Load YAML content into a dictionary."""
    try:
        import yaml  # type: ignore
    except ImportError as exc:
        raise RuntimeError("YAML support requires PyYAML.") from exc
    return yaml.safe_load(raw_text) or {}


@dataclass(frozen=True)
class Rule:
    """A detection rule that can match findings and generate new findings."""

    id: str
    description: str
    severity: str | None = None
    control_ids: list[str] | None = None
    conditions: dict[str, Any] = field(default_factory=dict)


class RuleSet:
    """Loads and stores rules from a YAML file."""

    def __init__(self, rules: list[Rule] | None = None):
        """
        Initialize a RuleSet with optional list of rules.

        Args:
            rules: Optional list of Rule objects to initialize with.
        """
        self._rules: list[Rule] = rules or []

    def load_from_file(self, file_path: str | Path) -> None:
        """
        Load rules from a YAML file.

        Expected YAML format:
        ```yaml
        rules:
          - id: rule_1
            description: "Rule description"
            severity: "high"
            control_ids: ["CIS-1.1", "NIST-AC-3"]
            conditions:
              severity: "high"
              title_contains: "port"
        ```

        Args:
            file_path: Path to the YAML file containing rules.

        Raises:
            FileNotFoundError: If the file does not exist.
            RuntimeError: If PyYAML is not installed or YAML parsing fails.
        """
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"Rule file not found: {path}")

        raw_text = path.read_text(encoding="utf-8")
        yaml_data = _load_yaml(raw_text)

        rules_data = yaml_data.get("rules", [])
        if not isinstance(rules_data, list):
            return

        self._rules = []
        for rule_data in rules_data:
            if not isinstance(rule_data, dict):
                continue
            rule_id = rule_data.get("id")
            if not rule_id:
                continue

            rule = Rule(
                id=str(rule_id),
                description=str(rule_data.get("description", "")),
                severity=rule_data.get("severity"),
                control_ids=rule_data.get("control_ids"),
                conditions=rule_data.get("conditions", {}),
            )
            self._rules.append(rule)

    def get_rules(self) -> list[Rule]:
        """
        Get all loaded rules.

        Returns:
            List of Rule objects.
        """
        return list(self._rules)


class RuleEngine:
    """Engine for evaluating findings against rules."""

    def __init__(self, rule_set: RuleSet | None = None):
        """
        Initialize the rule engine with an optional rule set.

        Args:
            rule_set: Optional RuleSet to use for evaluation.
        """
        self.rule_set = rule_set or RuleSet()

    def evaluate(self, findings: list[Finding]) -> list[Finding]:
        """
        Evaluate findings against rules and return new findings generated by matching rules.

        Rules are matched based on their conditions. For each rule that matches a finding,
        a new Finding is generated with the rule's description, severity, and control_ids.

        Condition matching supports:
        - Equality: `{"severity": "high"}` matches findings where severity equals "high"
        - Contains: `{"title_contains": "port"}` matches findings where title contains "port"
        - Multiple conditions are ANDed together (all must match)

        Args:
            findings: List of Finding objects to evaluate.

        Returns:
            List of new Finding objects generated by matching rules.
            Original findings are not modified.
        """
        new_findings: list[Finding] = []
        rules = self.rule_set.get_rules()

        for rule in rules:
            for finding in findings:
                if self._rule_matches_finding(rule, finding):
                    new_finding = self._create_finding_from_rule(rule, finding)
                    new_findings.append(new_finding)

        return new_findings

    @staticmethod
    def _rule_matches_finding(rule: Rule, finding: Finding) -> bool:
        """
        Check if a rule's conditions match a finding.

        Args:
            rule: Rule to check.
            finding: Finding to check against.

        Returns:
            True if all conditions match, False otherwise.
        """
        conditions = rule.conditions
        if not conditions:
            return False

        for key, expected_value in conditions.items():
            if key.endswith("_contains"):
                # Contains matching: title_contains, description_contains, etc.
                field_name = key[:-9]  # Remove "_contains" suffix
                field_value = _get_finding_field_value(finding, field_name)
                if field_value is None:
                    return False
                if not isinstance(field_value, str) or not isinstance(expected_value, str):
                    return False
                if expected_value.lower() not in field_value.lower():
                    return False
            else:
                # Equality matching: severity, title, etc.
                field_value = _get_finding_field_value(finding, key)
                if field_value != expected_value:
                    return False

        return True

    @staticmethod
    def _create_finding_from_rule(rule: Rule, original_finding: Finding) -> Finding:
        """
        Create a new Finding from a rule match.

        Args:
            rule: Rule that matched.
            original_finding: Original finding that triggered the rule.

        Returns:
            New Finding object with rule's description, severity, and control_ids.
        """
        return Finding(
            title=f"Rule {rule.id} triggered",
            description=rule.description,
            severity=rule.severity or original_finding.severity,
            evidence={
                "rule_id": rule.id,
                "original_finding_title": original_finding.title,
                "original_finding_severity": original_finding.severity,
            },
            control_ids=rule.control_ids,
        )


def _get_finding_field_value(finding: Finding, field_name: str) -> Any:
    """
    Get the value of a Finding field by name.

    Args:
        finding: Finding object.
        field_name: Name of the field to get.

    Returns:
        Field value, or None if field doesn't exist.
    """
    if hasattr(finding, field_name):
        return getattr(finding, field_name)
    return None
